<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>yaws</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">yaws</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>yaws io_uring abstracts the underlying low level Linux io_uring library.</p>
<p>We aim too provide safer semantics towards managing all the moving parts given these have complex lifetimes and ownership, typically shared between the kernel, userspace and the user.</p>
<p><img src="images/high_level.jpg" alt="high-level" /></p>
<h2 id="bearer"><a class="header" href="#bearer">Bearer</a></h2>
<p>UringBearer (io-uring-bearer) is the carrier holding all of the io_uring associated generated instances of types.</p>
<h2 id="opcode"><a class="header" href="#opcode">OpCode</a></h2>
<p>OpCode and OpCode (io-uring-opcode) are the contracts between bearer and individual opcode implementations.</p>
<p>In addition it provides the required extension traits for implementing the individual opcodes.</p>
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<p>Owner (io-uring-owner) provides the ownership semantics between kernel, userspace and the user.</p>
<h2 id="filehandles"><a class="header" href="#filehandles">Filehandles</a></h2>
<p>RegisteredFd and FdKind (io-uring-fd) provides the types representing filehandles within io_uring.</p>
<h2 id="buffers"><a class="header" href="#buffers">Buffers</a></h2>
<p>UringBuffer (io-uring-buffer) will provide the types representing buffers within io_uring.</p>
<p><strong>Note</strong>: As of time writing buffers are still within the bearer but this will change.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bearer-1"><a class="header" href="#bearer-1">Bearer</a></h1>
<p>The crate io-uring-bearer consists of the below main types:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/struct.UringBearer.html">UringBearer</a></td><td style="text-align: left">The main carrier type holding all the instaces of Completion, Registered Filehandles &amp; Buffers</td></tr>
<tr><td style="text-align: left"><a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/error/enum.UringBearerError.html">UringBearerError</a></td><td style="text-align: left">The error type for UringBearer</td></tr>
<tr><td style="text-align: left"><a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/enum.BearerCapacityKind.html">BearerCapacityKind</a></td><td style="text-align: left">Descriptor used to describe the boundaries of capacities required</td></tr>
<tr><td style="text-align: left"><a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/enum.Completion.html">Completion</a></td><td style="text-align: left">The main completion type bringing together all the possible competions</td></tr>
</tbody></table>
</div>
<h2 id="associated-built-in-types"><a class="header" href="#associated-built-in-types">Associated Built-In Types</a></h2>
<p>The below will be migrated into separate crates, implementing the io-uring-opcode trait later, similar to EpollCtl.</p>
<p>Until then, io-uring-bearer still holds some of the required holding types:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Holding Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/slab/struct.BuffersRec.html">BuffersRec</a></td><td style="text-align: left">Holds the actual allocation for the Buffers that either owned by the Kernel or Userspace.</td></tr>
<tr><td style="text-align: left"><a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/slab/enum.FutexRec.html">FutexRec</a></td><td style="text-align: left">futex2(2) -like, Used for FutexWait</td></tr>
</tbody></table>
</div>
<p>In addition io-uring-bearer still holds some of the individual OpCode Pending / Completion slab types:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">OpCode Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/slab/enum.AcceptRec.html">AcceptRec</a></td><td style="text-align: left">accept4(2), used for Accept and AcceptMulti</td></tr>
<tr><td style="text-align: left"><a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/slab/struct.FutexWaitRec.html">FutexWaitRec</a></td><td style="text-align: left">Represents FutexWait</td></tr>
<tr><td style="text-align: left"><a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/slab/struct.RecvRec.html">RecvRec</a></td><td style="text-align: left">Represents Recv</td></tr>
<tr><td style="text-align: left"><a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/slab/struct.RecvMultiRec.html">RecvMultiRec</a></td><td style="text-align: left">Represents RecvMulti</td></tr>
<tr><td style="text-align: left"><a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/slab/enum.SendZcRec.html">SendZcRec</a></td><td style="text-align: left">Represents SendZc</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="capacity"><a class="header" href="#capacity">Capacity</a></h1>
<p><a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/struct.UringBearer.html">UringBearer</a> requires bounded capacities described to it.</p>
<p>Leaving things unbounded and without any capacity planning, it would be easy to create opportunities for denial of service, crashes etc. resulting from unbounded capacities at runtime.</p>
<p>All consumers must describe the required capacities through <a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/enum.BearerCapacityKind.html">BearerCapacityKind</a> type.</p>
<p>Given that the capacity is described and used at runtime context,</p>
<p>You should test your intended runtime with the described capacity to ensure that the given environment meets it where ever it's deployed in.</p>
<p>Anything that hits the capacity will typically see <a href="https://docs.rs/slabbable/latest/slabbable/enum.SlabbableError.html">SlabbableError</a> <code>AtCapacity(setting)</code> variant.</p>
<p>The capacity values are only used when the UringBearer is constructed and are not changeable within it's lifetime after.</p>
<p>See the <a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/enum.BearerCapacityKind.html">BearerCapacityKind</a> for an example how to use it along the <a href="https://docs.rs/capacity/latest/capacity/">capacity</a> crate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slabbable"><a class="header" href="#slabbable">Slabbable</a></h1>
<p>See <a href="https://github.com/pinkforest/pinkforest/blob/main/2025-01-25-slabbable.md">blog</a> which describes the <a href="https://docs.rs/slabbable/latest/slabbable/trait.Slabbable.html">Slabbable</a> trait in general.</p>
<p>Normal Vec etc. would implicitly allocate without warning and invalidate the underlying addresses.</p>
<p>Given that memory addresses need to be kept stable for many things submitted to the io_uring queue,</p>
<p><a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/struct.UringBearer.html">UringBearer</a> uses <a href="https://docs.rs/slabbable/latest/slabbable/trait.Slabbable.html">Slabbable</a> to back the underlying pending or completed instances of <a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/enum.Completion.html">Completion</a>.</p>
<p>Any top-level binary can configure the desired Slabbable implementation through <a href="https://docs.rs/slabbable-impl-selector/latest/slabbable_impl_selector/">SelectedSlab</a>.</p>
<p>By default the crate currently uses nohash-hasher through HashBrown through <a href="https://docs.rs/slabbable-hash/latest/slabbable_hash/">slabbable-hash</a>.</p>
<h2 id="completions"><a class="header" href="#completions">Completions</a></h2>
<p>We exploit the fact that Kernel doesn't make any opinion what the userdata should contain for the pending completions by giving each submission a rotating u64 identifier which can then be mapped into the completed type upon completion.</p>
<p>This avoids using any from_raw_parts -like re-construction when we can refer through rotating u64 serial through storage.</p>
<p>We could also use <a href="https://doc.rust-lang.org/std/mem/fn.forget.html">std::mem::forget</a> but we can also model this through the trait giving the option to the user what kind of storage they would like.</p>
<p>Main reason we like to track the items is we that can have some level of ownership / pointer provenance, manage easily any associated data (e.g. regarding the ownership) and more importantly we can construct a gated accessor / barrier to it whilst when for example the kernel has only immutable reference to the said data meaning we can also hold immutable references whilst doing so where as simply forgetting the submitted data.</p>
<p>Not only this but sometimes you might have an arena of buffers (e.g. group of buffers) that are provided to kernel and you must handle the ownership status of window / slice into the part of group of continuous buffers that have been provided back essentially fragmenting the type in some scenarios.</p>
<p>In short, the trait gives us the flexibility and we are able to test that all the implementations uphold the guarantees whilst leaving us easy way to benchmark any possible scenarios through the varying implementation in one go.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="opcode-1"><a class="header" href="#opcode-1">OpCode</a></h1>
<p>All io_uring operations or ops are described through their opcodes.</p>
<p>The below opcodes are currently implemented:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">OpCode</th><th style="text-align: left">Linux Kernel</th><th style="text-align: left">trait / built-in</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Accept</td><td style="text-align: left"></td><td style="text-align: left">built-in</td><td style="text-align: left">accept4(2) (single-shot)</td></tr>
<tr><td style="text-align: left">EpollCtl</td><td style="text-align: left"></td><td style="text-align: left">trait impl</td><td style="text-align: left">Epoll Control</td></tr>
<tr><td style="text-align: left">FuteXWait</td><td style="text-align: left"></td><td style="text-align: left">built-in</td><td style="text-align: left">Futex Wait</td></tr>
<tr><td style="text-align: left">ProvideBuffers</td><td style="text-align: left"></td><td style="text-align: left">built-in</td><td style="text-align: left">Register Buffers with Kernel for faster I/O</td></tr>
<tr><td style="text-align: left">Recv</td><td style="text-align: left"></td><td style="text-align: left">built-in</td><td style="text-align: left">Receive (single-shot)</td></tr>
<tr><td style="text-align: left">RecvMulti</td><td style="text-align: left"></td><td style="text-align: left">built-in</td><td style="text-align: left">Receive (multi-shot)</td></tr>
<tr><td style="text-align: left">SendZc</td><td style="text-align: left"></td><td style="text-align: left">built-in</td><td style="text-align: left">Send (Zero Copy)</td></tr>
</tbody></table>
</div>
<p>All the in-Bearer built-in OpCodes will be moved to implement the associated <a href="https://docs.rs/io-uring-opcode/latest/io_uring_opcode/">trait</a> in the future.</p>
<p>All the builti-in &amp; OpCode<C> + OpCompletion <a href="https://docs.rs/io-uring-opcode/latest/io_uring_opcode/">trait</a> impls are mapped into <a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/enum.Completion.html">Completion</a> enum.</p>
<p>To push a bearer-aware submission, use the push_* or push_op_typed methods via the associated <a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/struct.UringBearer.html">UringBearer</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accept"><a class="header" href="#accept">Accept</a></h1>
<p>Accept abstracts the underlying <a href="https://docs.rs/io-uring/latest/io_uring/opcode/struct.Accept.html">io_uring::opcode::Accept</a>.</p>
<p>This Single-shot Accept provides the source socket address and port within the completion.</p>
<p>If you either don't need the source address and / or port, consider using the AcceptMulti instead.</p>
<p><strong>Note</strong>: This is being migrated to implement the OpCode + OpCompletion traits similar to EpollCtl.</p>
<h2 id="submission"><a class="header" href="#submission">Submission</a></h2>
<p>You can currently push single-shot Accept unsafely depending on whether the underlying TcpListener RawFd is IPv4 or IPv6:</p>
<ul>
<li>IPv4: <a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/struct.UringBearer.html#method.add_accept_ipv4">UringBearer::add_accept_ipv4</a></li>
<li>IPv6: <a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/struct.UringBearer.html#method.add_accept_ipv6">UringBearer::add_accept_ipv6</a></li>
</ul>
<p>To use it safely, user must ensure that the underlying socket is either exclusively IPv4 or IPv6 given the returned source address and structure layout is different depending on which one it is.</p>
<p>If someone needs UNIX sockets, please feel free to <a href="https://github.com/yaws-rs/io_uring-utils">send a PR</a>.</p>
<h2 id="completion"><a class="header" href="#completion">Completion</a></h2>
<p>Accept(<a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/slab/enum.AcceptRec.html">AcceptRec</a>) will show up as normal through the handler API through <a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/struct.UringBearer.html">UringBearer</a>.</p>
<h2 id="lifetime-manual-handling"><a class="header" href="#lifetime-manual-handling">Lifetime (Manual handling)</a></h2>
<p><a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/completion/enum.SubmissionRecordStatus.html">SubmissionRecordStatus::Forget</a> is safe given the pending Completion was Single-shot.</p>
<p>If the completed record is retained, this will result in memoryleak.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epollctl"><a class="header" href="#epollctl">EpollCtl</a></h1>
<p>EpollCtl abstracts the underlying <a href="https://docs.rs/io-uring/latest/io_uring/opcode/struct.EpollCtl.html">io_uring::opcode::EpollCtl</a>.</p>
<p>You can use io_uring to batch the control calls of Epoll.</p>
<p>For now the separate <a href="https://docs/io-uring-epoll">io-uring-epoll</a> crate also provides a convenient syscall abstraction into epoll_wait which is not yet available through the io_uring interaface over a regular syscall as of now.</p>
<p>If you have millions of sockets that constantly change status, it is helpful to be able to batch the control calls.</p>
<p>See the <a href="https://github.com/yaws-rs/io_uring-utils/tree/main/io-uring-epoll/examples">examples</a> from the io-uring-epoll repository.</p>
<p><strong>Note</strong>: io-uring-epoll 0.1 crate is different to 0.2 which implements the new OpCode/Completion traits.</p>
<h2 id="construct"><a class="header" href="#construct">Construct</a></h2>
<ul>
<li>Construct associated <a href="https://docs.rs/io-uring-epoll/0.2.0-pre1/io_uring_epoll/struct.EpollCtl.html#method.with_epfd_handled">EpollUringHandler::with_bearer(UringBearer)</a>.</li>
<li>Construct <a href="https://docs.rs/io-uring-epoll/0.2.0-pre1/io_uring_epoll/struct.HandledFd.html">HandledFd</a> representing individual Epoll triggered RawFd</li>
</ul>
<h2 id="submission-1"><a class="header" href="#submission-1">Submission</a></h2>
<ul>
<li>Construct <a href="https://docs.rs/io-uring-epoll/0.2.0-pre1/io_uring_epoll/struct.EpollCtl.html#method.with_epfd_handled">EpollCtl::with_epfd_handled(epfd, handle_fd, your_reference)</a></li>
<li>Use <a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/struct.UringBearer.html#method.push_epoll_ctl">UringBearer::push_epoll_ctl</a> to push the constructed EpollCtl as submission.</li>
</ul>
<h2 id="completion-1"><a class="header" href="#completion-1">Completion</a></h2>
<p>EpollCtl(impl <a href="https://docs.rs/io-uring-opcode/latest/io_uring_opcode/trait.OpExtEpollCtl.html">OpExtEpollCtl</a>) will show up as normal through the handler API through UringBearer.</p>
<h2 id="lifetime-manual-handling-1"><a class="header" href="#lifetime-manual-handling-1">Lifetime (Manual handling)</a></h2>
<p>You should only Forget the underlying EpollCtl when the RawFd is removed from monitored filehandles list.</p>
<p>Failing to Retain the underlying EpollCtl before removing it will result in undefined behaviour.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="futexwait"><a class="header" href="#futexwait">FutexWait</a></h1>
<p>FutexWait abstracts the underlying <a href="https://docs.rs/io-uring/latest/io_uring/opcode/struct.FutexWait.html">io_uring::opcode::FutexWait</a>.</p>
<p>This can be used, among other use-cases, to combine epoll_wait or other events waiting on another thread with io_uring completions given atomics can be used to generate completion events through FutexWait.</p>
<p><strong>Note</strong>: This is being migrated to implement the OpCode + OpCompletion traits similar to EpollCtl.</p>
<h2 id="construct-1"><a class="header" href="#construct-1">Construct</a></h2>
<p>You can create the underlying indexed AtomicU32 which will be owned by the UringBearer through:</p>
<ul>
<li><a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/struct.UringBearer.html#method.create_futex_atomic">UringBearer::create_futex_atomic</a></li>
</ul>
<p>Alternatively and unsafely you can provide your own AtomicU32 to UringBearer through:</p>
<ul>
<li><a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/struct.UringBearer.html#method.supply_futex_atomic_raw">UringBearer::supply_futex_atomic_raw</a></li>
</ul>
<h2 id="submission-2"><a class="header" href="#submission-2">Submission</a></h2>
<p>You can submit a FutexWait through <a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/struct.UringBearer.html#method.add_futex_wait">UringBearer::add_futex_wait</a>.</p>
<h2 id="completion-2"><a class="header" href="#completion-2">Completion</a></h2>
<p>FutexWait(<a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/slab/struct.FutexWaitRec.html">FutexWaitRec</a>) will show up as normal through the handler API through UringBearer.</p>
<h2 id="lifetime-manual-handling-2"><a class="header" href="#lifetime-manual-handling-2">Lifetime (Manual handling)</a></h2>
<p>SubmissionRecordStatus::Forget is safe given the pending Completion was Single-shot.</p>
<p>If the completed record is retained, this will result in memoryleak.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="providebuffers"><a class="header" href="#providebuffers">ProvideBuffers</a></h1>
<p>ProvideBuffers abstracts the underlying <a href="https://docs.rs/io-uring/latest/io_uring/opcode/struct.ProvideBuffers.html">io_uring::opcode::ProvideBuffers</a>.</p>
<p>To do faster I/O it is essential to register (or map) any userspace buffers with the kernel so the kernel can spend less time mapping the userspace buffers between the Recv / Send calls.</p>
<p><strong>Note</strong>: This is being migrated to implement the OpCode + OpCompletion traits similar to EpollCtl.</p>
<h2 id="construct-2"><a class="header" href="#construct-2">Construct</a></h2>
<p>See the main section about <a href="opcode/../buffers.html">Buffers</a> how to manage these.</p>
<h2 id="submission-3"><a class="header" href="#submission-3">Submission</a></h2>
<p>Use the <a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/struct.UringBearer.html#method.provide_buffers">UringBearer::provide_buffers</a> to both submit and associate any created <a href="opcode/../buffers.html">Buffers</a> with kernel-mapped identifiers.</p>
<p>We may later have API to make this more easier to use but for now the user must keep track of the kernel-mapped identifiers.</p>
<h2 id="completion-3"><a class="header" href="#completion-3">Completion</a></h2>
<p>ProvideBuffers(<a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/slab/struct.ProvideBuffersRec.html">ProvideBuffersRec</a>) is provided normally through the handler API via UringBearer.</p>
<h2 id="lifetime-manual-handling-3"><a class="header" href="#lifetime-manual-handling-3">Lifetime (Manual handling)</a></h2>
<p>The actual buffers are separate from the registering it so the submission can be forgotten after completion safely.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recv"><a class="header" href="#recv">Recv</a></h1>
<p>Single-shot Recv abstracts the underlying <a href="https://docs.rs/io-uring/latest/io_uring/opcode/struct.Recv.html">io_uring::opcode::Recv</a>.</p>
<p><strong>Note</strong>: This is being migrated to implement the OpCode + OpCompletion traits similar to EpollCtl.</p>
<h2 id="construct-3"><a class="header" href="#construct-3">Construct</a></h2>
<p>Recv requires a registered filehandle and previously created indexed buffer.</p>
<h2 id="submission-4"><a class="header" href="#submission-4">Submission</a></h2>
<p>Use <a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/struct.UringBearer.html#method.add_recv">UringBearer::add_recv</a> to submit a Single-shot Recv to kernel.</p>
<h2 id="completion-4"><a class="header" href="#completion-4">Completion</a></h2>
<p>Recv(<a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/slab/struct.RecvRec.html">RecvRec</a>) is provided normally through the handler API via UringBearer.</p>
<h2 id="lifetime-manual-handling-4"><a class="header" href="#lifetime-manual-handling-4">Lifetime (Manual handling)</a></h2>
<p><a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/completion/enum.SubmissionRecordStatus.html">SubmissionRecordStatus::Forget</a> is safe given the pending Completion was Single-shot.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recvmulti"><a class="header" href="#recvmulti">RecvMulti</a></h1>
<p>RecvMulti abstracts the underlying [io_uring::opcode::RecvMulti](https://docs.rs/io-uring/latest/io_uring/opcode/struct.Recv
Multi.html).</p>
<p><strong>Note</strong>: This is being migrated to implement the OpCode + OpCompletion traits similar to EpollCtl.</p>
<h2 id="construct-4"><a class="header" href="#construct-4">Construct</a></h2>
<p>RecvMulti requires both a registered filehandle and previously registered / kernel-mapped buffer/s with the referred group.</p>
<h2 id="submission-5"><a class="header" href="#submission-5">Submission</a></h2>
<p>Use <a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/struct.UringBearer.html#method.add_recv_multi">UringBearer::add_recv_multi</a> to submit a RecvMulti to kernel.</p>
<h2 id="completion-5"><a class="header" href="#completion-5">Completion</a></h2>
<p>RecvMulti(<a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/slab/struct.RecvMultiRec.html">RecvMultiRec</a>) is provided normally through the handler API via UringBearer.</p>
<p>See <a href="opcode/../buffers.html">Buffers</a> on how to deal with individual "selected buffers" within registered "grouped" Buffers.</p>
<h2 id="lifetime-manual-handling-5"><a class="header" href="#lifetime-manual-handling-5">Lifetime (Manual handling)</a></h2>
<p>It would be undefined behaviour if the submission record is invalidated before the Multi-shot submission is either confirmed cancelled or timed out.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sendzc"><a class="header" href="#sendzc">SendZc</a></h1>
<p>SendZc abstracts the underlying <a href="https://docs.rs/io-uring/latest/io_uring/opcode/struct.SendZc.html">io_uring::opcode::SendZc</a>.</p>
<p><strong>Note</strong>: This is being migrated to implement the OpCode + OpCompletion traits similar to EpollCtl.</p>
<h2 id="construct-5"><a class="header" href="#construct-5">Construct</a></h2>
<p>Currently SendZc requires the associated indexing (through submission) into:</p>
<ul>
<li>registered filehandle (see <a href="opcode/../filehandles.html">Filehandles</a></li>
<li>registered buffer (see <a href="opcode/../buffers.html">Buffers</a></li>
<li>kernel buffer id (see <a href="opcode/../buffers.html">Buffers</a></li>
</ul>
<h2 id="submission-6"><a class="header" href="#submission-6">Submission</a></h2>
<p>Currently submit using <a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/struct.UringBearer.html#method.add_send_singlebuf">UringBearer::add_send_singlebuf</a>.</p>
<h2 id="completion-6"><a class="header" href="#completion-6">Completion</a></h2>
<p>SendZc(<a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/slab/enum.SendZcRec.html">SendZcRec</a>) is provided normally through the handler API via UringBearer.</p>
<h2 id="lifetime-manual-handling-6"><a class="header" href="#lifetime-manual-handling-6">Lifetime (Manual handling)</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extensions"><a class="header" href="#extensions">Extensions</a></h1>
<p>Every OpCode should add:</p>
<ul>
<li>It's own separate crate (e.g. <a href="https://docs.rs/io-uring-epoll">io-uring-epoll</a>) and it's own type (e.g. <a href="https://docs.rs/io-uring-epoll/0.2.0-pre1/io_uring_epoll/struct.EpollCtl.html">EpollCtl</a>).</li>
<li>Impl <a href="https://docs.rs/io-uring-opcode/latest/io_uring_opcode/trait.OpCode.html">OpCode</a> and <a href="https://docs.rs/io-uring-opcode/latest/io_uring_opcode/trait.OpCompletion.html">OpCompletion</a> from the <a href="https://docs.rs/io-uring-opcode/latest/io_uring_opcode/">io-uring-opcode</a> crate.</li>
<li>Feature-gated "extension" trait within <a href="https://docs.rs/io-uring-opcode/latest/io_uring_opcode/">io-uring-opcode</a> similar to <a href="https://docs.rs/io-uring-opcode/latest/io_uring_opcode/trait.OpExtEpollCtl.html">OpExtEpollCtl</a>.</li>
<li>Feature-gated <a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/enum.Completion.html">UringBearer::Completion</a> variant, e.g. <a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/enum.Completion.html#variant.EpollCtl">Completion::EpollCtl</a> within UringBearer.</li>
<li>Explicit API to push the OpCode as submission, e.g. <a href="https://docs.rs/io-uring-bearer/latest/io_uring_bearer/struct.UringBearer.html#method.push_epoll_ctl">UringBearer::push_epoll_ctl</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-1"><a class="header" href="#ownership-1">Ownership</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filehandles-1"><a class="header" href="#filehandles-1">Filehandles</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="buffers-1"><a class="header" href="#buffers-1">Buffers</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
